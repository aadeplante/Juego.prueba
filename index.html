<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1942: Asteroid Field</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }
        canvas {
            display: block;
            background-color: #000;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 2px 2px 0 #000;
        }
        .hud-bar {
            display: inline-block;
            width: 100px;
            height: 10px;
            border: 2px solid #fff;
            background: #333;
        }
        #shield-fill {
            height: 100%;
            background-color: #00ff00;
            width: 100%;
            transition: width 0.2s, background-color 0.2s;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            background: #000;
            padding: 30px;
            border: 4px solid #cc0000;
            z-index: 20;
            box-shadow: 10px 10px 0 #880000;
        }
        h1 { margin: 0; color: #cc0000; text-transform: uppercase; font-size: 32px; font-weight: bold; letter-spacing: 5px;}
        p { color: #fff; font-size: 18px; margin: 20px 0; }
        button.retry-btn {
            background: #cc0000;
            color: #fff;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 5px 5px 0 #550000;
        }
        button.retry-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 3px 3px 0 #550000;
        }
        
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 140px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            z-index: 15;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .btn:active, .btn.pressed {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .btn-fire {
            width: 90px;
            height: 90px;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
            color: #ff0000;
        }
        .btn-fire:active, .btn-fire.pressed {
            background: rgba(255, 0, 0, 0.5);
            color: white;
            box-shadow: 0 0 15px #ff0000;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div>SCORE: <span id="score" style="color:#fff">0</span></div>
        <div style="margin-top:5px;">
            SHIELD: 
            <div class="hud-bar"><div id="shield-fill"></div></div>
        </div>
        <div>LIVES: <span id="lives" style="color:#0f0">3</span></div>
        <div id="controls-hint" style="font-size: 12px; color: #888; margin-top: 5px;">üéµ Toca para activar Audio 1942</div>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <p>SCORE: <span id="final-score">0</span></p>
        <button class="retry-btn" onclick="reiniciarJuego()">INSERT COIN</button>
    </div>

    <div id="mobile-controls">
        <div class="control-group">
            <div class="btn" id="btn-left">‚óÄ</div>
            <div class="btn" id="btn-right">‚ñ∂</div>
        </div>
        <div class="control-group">
            <div class="btn" id="btn-thrust">‚ñ≤</div>
            <div class="btn btn-fire" id="btn-fire">‚óè</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    /** --- AUDIO ENGINE & 1942 MUSIC --- **/
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    // Notas de frecuencia para la m√∫sica
    const N = {
        c4: 261.63, d4: 293.66, e4: 329.63, f4: 349.23, g4: 392.00, a4: 440.00, b4: 493.88,
        c5: 523.25, d5: 587.33, e5: 659.25, f5: 698.46, g5: 783.99, a5: 880.00, b5: 987.77,
        c6: 1046.50
    };

    const music = {
        isPlaying: false,
        noteIndex: 0,
        nextNoteTime: 0,
        tempo: 160, // Marcha r√°pida estilo 1942
        // Melod√≠a principal aproximada de 1942 (Silbato/Marcha)
        melody: [
            // Intro Riff (Morse code style)
            {f: N.g5, d: 0.5}, {f: N.g5, d: 0.5}, {f: N.g5, d: 0.5}, {f: 0, d: 0.5},
            {f: N.e5, d: 0.5}, {f: N.e5, d: 0.5}, {f: N.e5, d: 0.5}, {f: 0, d: 0.5},
            
            // Main Theme Loop
            {f: N.c5, d: 1}, {f: N.g4, d: 1}, {f: N.c5, d: 1}, {f: N.e5, d: 1}, // Taan tan taan tan
            {f: N.g5, d: 2}, {f: N.e5, d: 1}, {f: N.c5, d: 1},
            {f: N.f5, d: 1}, {f: N.e5, d: 1}, {f: N.d5, d: 1}, {f: N.c5, d: 1},
            {f: N.d5, d: 2}, {f: N.g4, d: 2},
            
            {f: N.c5, d: 1}, {f: N.g4, d: 1}, {f: N.c5, d: 1}, {f: N.e5, d: 1},
            {f: N.g5, d: 2}, {f: N.a5, d: 1}, {f: N.g5, d: 1},
            {f: N.f5, d: 0.75}, {f: N.e5, d: 0.75}, {f: N.d5, d: 0.75}, {f: N.e5, d: 0.75}, 
            {f: N.c5, d: 2}, {f: 0, d: 2} // Loop gap
        ],
        
        playNote: function(freq, duration) {
            if(audioCtx.state === 'suspended') return;
            if(freq > 0) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                // Onda cuadrada con ciclo de trabajo variable simulado (filtro)
                // para que suene a "silbido 8-bits"
                osc.type = 'square'; 
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                
                // Envolvente percusiva (staccato)
                gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (duration * 0.8));

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            }
        },
        
        scheduler: function() {
            // Buffer de notas
            while (this.nextNoteTime < audioCtx.currentTime + 0.1) {
                if(this.isPlaying) {
                    const note = this.melody[this.noteIndex];
                    const secondsPerBeat = 60.0 / this.tempo;
                    const duration = note.d * secondsPerBeat;
                    
                    this.playNote(note.f, duration);
                    
                    this.nextNoteTime += duration;
                    this.noteIndex++;
                    
                    // Loop: Saltamos la intro despu√©s de la primera vez
                    if(this.noteIndex >= this.melody.length) {
                        this.noteIndex = 8; 
                    }
                } else {
                    return; 
                }
            }
            if(this.isPlaying) {
                this.timerID = requestAnimationFrame(this.scheduler.bind(this));
            }
        },

        start: function() {
            if(this.isPlaying) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            this.isPlaying = true;
            this.noteIndex = 0;
            this.nextNoteTime = audioCtx.currentTime;
            this.scheduler();
        },
        stop: function() {
            this.isPlaying = false;
            cancelAnimationFrame(this.timerID);
        }
    };
    
    const initAudio = () => { 
        if (audioCtx.state === 'suspended') audioCtx.resume(); 
        music.start();
    };

    const sfx = {
        shoot: () => {
            // Sonido disparo r√°pido y agudo
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.type = 'square'; 
            osc.frequency.setValueAtTime(800, audioCtx.currentTime); 
            osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.08);
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.08);
            osc.start(); osc.stop(audioCtx.currentTime + 0.08);
        },
        enemyShoot: () => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.type = 'triangle'; 
            osc.frequency.setValueAtTime(1000, audioCtx.currentTime); 
            osc.frequency.linearRampToValueAtTime(1500, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.03, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        },
        hit: () => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.start(); osc.stop(audioCtx.currentTime + 0.1);
        },
        explode: () => {
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            noise.connect(gain); gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            noise.start();
        },
        mineAlarm: () => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.type = 'square';
            osc.frequency.setValueAtTime(600, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.start(); osc.stop(audioCtx.currentTime + 0.3);
        }
    };
    
    // Sonido motor continuo
    let thrustOsc = null, thrustGain = null;
    const startThrustSound = () => {
        if (!thrustOsc && audioCtx.state === 'running') {
            thrustOsc = audioCtx.createOscillator();
            thrustGain = audioCtx.createGain();
            thrustOsc.connect(thrustGain);
            thrustGain.connect(audioCtx.destination);
            thrustOsc.type = 'sawtooth';
            thrustOsc.frequency.setValueAtTime(60, audioCtx.currentTime);
            thrustGain.gain.setValueAtTime(0.05, audioCtx.currentTime);
            thrustOsc.start();
        }
    };
    const stopThrustSound = () => {
        if (thrustOsc) {
            thrustGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
            setTimeout(() => { if(thrustOsc) { thrustOsc.stop(); thrustOsc.disconnect(); thrustOsc = null; } }, 100);
        }
    };

    /** CONFIGURACI√ìN **/
    const FPS = 60;
    const FRICTION = 0.7; 
    const SHIP_SIZE = 30; 
    const TURN_SPEED = 360; 
    const SHIP_THRUST = 5; 
    const LASER_MAX = 50; 
    const LASER_SPD = 800; 
    const LASER_DIST = 0.6; 
    const ROIDS_NUM = 4; 
    const ROIDS_SIZE = 90; 
    const ROIDS_SPD = 50; 
    const MINES_NUM = 3; 
    
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    };
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    let level, lives, roids, mines, enemyLasers, score, ship;
    let gameOver = false;
    let propAngle = 0; 

    // Nave Estilo P-38 Lightning (Contexto previo)
    const newShip = () => {
        return {
            x: canvas.width / 2,
            y: canvas.height / 2,
            a: 90 / 180 * Math.PI, 
            r: SHIP_SIZE / 2,
            blinkNum: 0,
            canShoot: true,
            dead: false,
            lasers: [],
            rot: 0,
            thrusting: false,
            thrust: { x: 0, y: 0 },
            hp: 3, 
            maxHp: 3
        }
    };

    const updateShieldUI = (hp) => {
        const bar = document.getElementById("shield-fill");
        const pct = (Math.max(0, hp) / 3) * 100;
        bar.style.width = pct + "%";
        if(hp === 3) bar.style.backgroundColor = "#00ff00";
        else if(hp === 2) bar.style.backgroundColor = "#ffff00";
        else bar.style.backgroundColor = "#ff0000";
    }

    const newAsteroid = (x, y, r) => {
        const lvlMult = 1 + 0.1 * level;
        const vert = Math.floor(Math.random() * 8 + 8); 
        const isSpiky = Math.random() < 0.5;
        const offs = [];
        for(let i=0; i<vert; i++) {
            if (isSpiky) {
                if(Math.random() < 0.4) offs.push(Math.random() * 0.6 + 1.2); 
                else offs.push(Math.random() * 0.4 + 0.5); 
            } else {
                offs.push(Math.random() * 0.4 + 0.8);
            }
        }
        return {
            x: x, y: y,
            xv: Math.random() * ROIDS_SPD * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1),
            yv: Math.random() * ROIDS_SPD * lvlMult / FPS * (Math.random() < 0.5 ? 1 : -1),
            r: r,
            a: Math.random() * Math.PI * 2,
            vert: vert,
            offs: offs,
            isSpiky: isSpiky
        };
    };

    const newMine = () => {
        let x, y;
        do {
            x = Math.floor(Math.random() * canvas.width);
            y = Math.floor(Math.random() * canvas.height);
        } while (distBetweenPoints(ship.x, ship.y, x, y) < 250);
        
        return {
            x: x, y: y,
            xv: (Math.random() - 0.5) * 15 / FPS, 
            yv: (Math.random() - 0.5) * 15 / FPS,
            r: 12, 
            pulse: 0,
            reload: Math.random() * 150 + 50 
        };
    };

    const createLevelObjects = () => {
        roids = [];
        mines = [];
        enemyLasers = [];
        let x, y;
        for (let i = 0; i < ROIDS_NUM + level; i++) {
            do {
                x = Math.floor(Math.random() * canvas.width);
                y = Math.floor(Math.random() * canvas.height);
            } while (distBetweenPoints(ship.x, ship.y, x, y) < ROIDS_SIZE * 2 + ship.r);
            roids.push(newAsteroid(x, y, Math.ceil(ROIDS_SIZE / 2)));
        }
        for (let i = 0; i < MINES_NUM + Math.floor(level/2); i++) {
            mines.push(newMine());
        }
    };

    const distBetweenPoints = (x1, y1, x2, y2) => {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    };

    let particles = [];
    const createExplosion = (x, y, color, amount = 15) => {
        for(let i=0; i<amount; i++) {
            particles.push({
                x: x, y: y,
                xv: (Math.random() - 0.5) * (Math.random() * 15),
                yv: (Math.random() - 0.5) * (Math.random() * 15),
                life: 30 + Math.random() * 20, 
                color: color,
                size: Math.random() * 3 + 1
            });
        }
    }

    const newGame = () => {
        score = 0; level = 0; lives = 3;
        ship = newShip();
        updateShieldUI(ship.hp);
        createLevelObjects();
        gameOver = false;
        document.getElementById("game-over").style.display = "none";
        document.getElementById("score").innerText = score;
        document.getElementById("lives").innerText = lives;
        loop();
    }

    const reiniciarJuego = () => { initAudio(); newGame(); };

    // Controles
    const rotateLeft = () => { initAudio(); ship.rot = TURN_SPEED / 180 * Math.PI / FPS; };
    const rotateRight = () => { initAudio(); ship.rot = -TURN_SPEED / 180 * Math.PI / FPS; };
    const stopRotation = () => ship.rot = 0;
    const startThrust = () => { initAudio(); ship.thrusting = true; startThrustSound(); };
    const stopThrust = () => { ship.thrusting = false; stopThrustSound(); };
    const fireWeapon = () => { initAudio(); shootBullets(); };
    const enableFire = () => ship.canShoot = true;

    document.addEventListener("keydown", (ev) => {
        if(gameOver) return;
        switch(ev.keyCode) {
            case 32: fireWeapon(); break;
            case 37: case 65: rotateLeft(); break;
            case 38: case 87: startThrust(); break;
            case 39: case 68: rotateRight(); break;
        }
    });
    document.addEventListener("keyup", (ev) => {
        if(gameOver) return;
        switch(ev.keyCode) {
            case 32: enableFire(); break;
            case 37: case 65: stopRotation(); break;
            case 38: case 87: stopThrust(); break;
            case 39: case 68: stopRotation(); break;
        }
    });

    const addTouchListener = (id, startAction, endAction) => {
        const btn = document.getElementById(id);
        const handleStart = (e) => { e.preventDefault(); if(!gameOver) startAction(); btn.classList.add("pressed"); };
        const handleEnd = (e) => { e.preventDefault(); if(!gameOver && endAction) endAction(); btn.classList.remove("pressed"); };
        btn.addEventListener("touchstart", handleStart, {passive: false});
        btn.addEventListener("touchend", handleEnd, {passive: false});
        btn.addEventListener("mousedown", handleStart);
        btn.addEventListener("mouseup", handleEnd);
        btn.addEventListener("mouseleave", () => { if(endAction) endAction(); btn.classList.remove("pressed"); });
    };
    addTouchListener("btn-left", rotateLeft, stopRotation);
    addTouchListener("btn-right", rotateRight, stopRotation);
    addTouchListener("btn-thrust", startThrust, stopThrust);
    addTouchListener("btn-fire", fireWeapon, enableFire);

    const shootBullets = () => {
        if (ship.canShoot && ship.lasers.length < LASER_MAX) {
            sfx.shoot();
            const fwdX = Math.cos(ship.a);
            const fwdY = -Math.sin(ship.a);
            const rightX = Math.sin(ship.a);
            const rightY = Math.cos(ship.a);
            
            const wingDist = 16; 
            const noseDist = 25; 

            ship.lasers.push({
                x: ship.x + (fwdX * noseDist) - (rightX * wingDist),
                y: ship.y + (fwdY * noseDist) - (rightY * wingDist),
                xv: LASER_SPD * fwdX / FPS,
                yv: LASER_SPD * fwdY / FPS,
                dist: 0, angle: ship.a
            });

            ship.lasers.push({
                x: ship.x + (fwdX * noseDist) + (rightX * wingDist),
                y: ship.y + (fwdY * noseDist) + (rightY * wingDist),
                xv: LASER_SPD * fwdX / FPS,
                yv: LASER_SPD * fwdY / FPS,
                dist: 0, angle: ship.a
            });
            ship.canShoot = false; 
        }
    };

    const shootEnemyLaser = (x, y) => {
        sfx.enemyShoot();
        const angle = Math.random() * Math.PI * 2; 
        enemyLasers.push({
            x: x, 
            y: y,
            xv: 400 * Math.cos(angle) / FPS, 
            yv: 400 * Math.sin(angle) / FPS,
            dist: 0,
            angle: angle
        });
    };

    const takeDamage = (instantKill = false) => {
        if (ship.blinkNum > 0 && !instantKill) return;

        if (instantKill) {
            ship.hp = 0;
            sfx.mineAlarm(); 
        } else {
            ship.hp--;
            sfx.hit();
        }
        
        updateShieldUI(ship.hp);

        if (ship.hp <= 0) {
            explodeShip();
        } else {
            ship.blinkNum = Math.ceil(FPS * 2);
            createExplosion(ship.x, ship.y, "yellow", 5);
        }
    };

    const explodeShip = () => {
        sfx.explode();
        stopThrustSound();
        ship.dead = true;
        createExplosion(ship.x, ship.y, "white", 30);
        createExplosion(ship.x, ship.y, "red", 20);
        lives--;
        document.getElementById("lives").innerText = lives;
        
        if (lives === 0) {
            gameOver = true;
            music.stop();
            document.getElementById("final-score").innerText = score;
            document.getElementById("game-over").style.display = "block";
        } else {
            setTimeout(() => {
                ship = newShip();
                updateShieldUI(ship.hp);
                ship.blinkNum = Math.ceil(FPS * 3);
            }, 1000);
        }
    };

    const destroyAsteroid = (index) => {
        const x = roids[index].x;
        const y = roids[index].y;
        const r = roids[index].r;
        score += (r > ROIDS_SIZE/2) ? 20 : 50;
        document.getElementById("score").innerText = score;
        sfx.explode();
        createExplosion(x, y, "#aaa"); 
        if (r > Math.ceil(ROIDS_SIZE / 4)) {
            roids.push(newAsteroid(x, y, Math.ceil(r / 2)));
            roids.push(newAsteroid(x, y, Math.ceil(r / 2)));
        }
        roids.splice(index, 1);
        checkLevelClear();
    };

    const destroyMine = (index) => {
        const x = mines[index].x;
        const y = mines[index].y;
        score += 150; 
        document.getElementById("score").innerText = score;
        sfx.explode();
        createExplosion(x, y, "red", 20);
        mines.splice(index, 1);
        checkLevelClear();
    }

    const checkLevelClear = () => {
        if (roids.length === 0 && mines.length === 0) {
            level++;
            createLevelObjects();
        }
    }

    const loop = () => {
        if (gameOver) return;

        ctx.fillStyle = "#001122"; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.strokeStyle = "#003344";
        ctx.lineWidth = 1;
        ctx.beginPath();
        const offset = (Date.now() / 50) % 40;
        for(let i=0; i<canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); }
        for(let i=0; i<canvas.height; i+=40) { ctx.moveTo(0,i + offset); ctx.lineTo(canvas.width,i + offset); }
        ctx.stroke();

        propAngle += 0.5;

        if (!ship.dead) {
            const blinkOn = ship.blinkNum % 10 < 5;
            if (ship.blinkNum > 0) ship.blinkNum--;

            if (ship.blinkNum == 0 || blinkOn) {
                if (ship.thrusting) {
                    ship.thrust.x += SHIP_THRUST * Math.cos(ship.a) / FPS;
                    ship.thrust.y -= SHIP_THRUST * Math.sin(ship.a) / FPS;
                } else {
                    ship.thrust.x -= FRICTION * ship.thrust.x / FPS;
                    ship.thrust.y -= FRICTION * ship.thrust.y / FPS;
                }

                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(-ship.a + Math.PI / 2); 
                
                ctx.fillStyle = "#aaccbb"; 
                ctx.strokeStyle = "#335533"; 
                ctx.lineWidth = 2;

                ctx.beginPath(); ctx.ellipse(0, 5, 8, 20, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                
                ctx.fillStyle = "#88ccff";
                ctx.beginPath(); ctx.ellipse(0, 0, 4, 8, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#aaccbb";

                ctx.beginPath(); ctx.rect(-20, 25, 40, 4); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.rect(-20, -10, 8, 40); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.rect(12, -10, 8, 40); ctx.fill(); ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(-35, 0); ctx.lineTo(35, 0); ctx.lineTo(35, 10); ctx.lineTo(-35, 10);
                ctx.closePath(); ctx.fill(); ctx.stroke();

                ctx.strokeStyle = `rgba(255, 255, 255, 0.6)`;
                ctx.beginPath(); ctx.moveTo(-16, -12);
                ctx.lineTo(-16 + Math.cos(propAngle)*12, -12 + Math.sin(propAngle)*12);
                ctx.moveTo(-16, -12); ctx.lineTo(-16 - Math.cos(propAngle)*12, -12 - Math.sin(propAngle)*12);
                ctx.stroke();
                ctx.beginPath(); ctx.moveTo(16, -12);
                ctx.lineTo(16 + Math.cos(propAngle)*12, -12 + Math.sin(propAngle)*12);
                ctx.moveTo(16, -12); ctx.lineTo(16 - Math.cos(propAngle)*12, -12 - Math.sin(propAngle)*12);
                ctx.stroke();

                if(ship.blinkNum > 0) {
                    ctx.strokeStyle = "cyan";
                    ctx.beginPath(); ctx.arc(0,0,35,0,Math.PI*2); ctx.stroke();
                }

                ctx.restore();
            }
        }

        // --- MINAS ---
        ctx.lineWidth = 2;
        for (let i = 0; i < mines.length; i++) {
            const m = mines[i];
            m.pulse += 0.1;
            m.reload--;

            // Disparar
            if (m.reload <= 0) {
                shootEnemyLaser(m.x, m.y);
                m.reload = Math.random() * 120 + 60; 
            }

            const scale = 1 + Math.sin(m.pulse) * 0.2;
            
            ctx.strokeStyle = "#ff0000";
            ctx.shadowBlur = 10;
            ctx.shadowColor = "red";
            
            ctx.save();
            ctx.translate(m.x, m.y);
            ctx.scale(scale, scale);
            ctx.beginPath(); ctx.arc(0, 0, m.r, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-m.r/2, -m.r/2); ctx.lineTo(m.r/2, m.r/2);
            ctx.moveTo(m.r/2, -m.r/2); ctx.lineTo(-m.r/2, m.r/2);
            ctx.stroke();
            ctx.restore();
            ctx.shadowBlur = 0;

            m.x += m.xv; m.y += m.yv;
            if (m.x < 0) m.x = canvas.width; else if (m.x > canvas.width) m.x = 0;
            if (m.y < 0) m.y = canvas.height; else if (m.y > canvas.height) m.y = 0;
        }

        // --- RENDERIZADO L√ÅSERES ENEMIGOS ---
        for (let i = enemyLasers.length - 1; i >= 0; i--) {
            const el = enemyLasers[i];
            
            ctx.strokeStyle = "#ff3333";
            ctx.lineWidth = 2; 
            ctx.shadowBlur = 5;
            ctx.shadowColor = "#ff0000";

            ctx.beginPath();
            ctx.moveTo(el.x, el.y);
            ctx.lineTo(el.x - 20 * Math.cos(el.angle), el.y - 20 * Math.sin(el.angle));
            ctx.stroke();
            ctx.shadowBlur = 0;

            el.x += el.xv; el.y += el.yv;
            el.dist += Math.sqrt(Math.pow(el.xv, 2) + Math.pow(el.yv, 2));

            if (!ship.dead && distBetweenPoints(el.x, el.y, ship.x, ship.y) < ship.r) {
                takeDamage(false); 
                enemyLasers.splice(i, 1);
                continue;
            }

            if (el.x < 0) el.x = canvas.width; else if (el.x > canvas.width) el.x = 0;
            if (el.y < 0) el.y = canvas.height; else if (el.y > canvas.height) el.y = 0;
            if (el.dist > canvas.width * 0.8) enemyLasers.splice(i, 1);
        }

        // --- DISPAROS JUGADOR ---
        for (let i = ship.lasers.length - 1; i >= 0; i--) {
            const l = ship.lasers[i];
            ctx.fillStyle = "#ffcc00"; 
            ctx.beginPath();
            ctx.arc(l.x, l.y, 3, 0, Math.PI*2);
            ctx.fill();
            
            ctx.strokeStyle = "rgba(255, 200, 0, 0.5)";
            ctx.beginPath(); ctx.moveTo(l.x, l.y);
            ctx.lineTo(l.x - 10*Math.cos(l.angle), l.y + 10*Math.sin(l.angle));
            ctx.stroke();

            l.x += l.xv; l.y += l.yv;
            l.dist += Math.sqrt(Math.pow(l.xv, 2) + Math.pow(l.yv, 2));
            if (l.x < 0) l.x = canvas.width; else if (l.x > canvas.width) l.x = 0;
            if (l.y < 0) l.y = canvas.height; else if (l.y > canvas.height) l.y = 0;
            if (l.dist > LASER_DIST * canvas.width) ship.lasers.splice(i, 1);
        }

        // --- ASTEROIDES ---
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        for (let i = 0; i < roids.length; i++) {
            const r = roids[i];
            if(r.isSpiky) ctx.strokeStyle = "#dddddd";
            else ctx.strokeStyle = "#ffffff";

            ctx.beginPath();
            for (let j = 0; j < r.vert; j++) {
                ctx.lineTo(
                    r.x + r.r * r.offs[j] * Math.cos(r.a + j * Math.PI * 2 / r.vert),
                    r.y + r.r * r.offs[j] * Math.sin(r.a + j * Math.PI * 2 / r.vert)
                );
            }
            ctx.closePath();
            ctx.stroke();
            r.x += r.xv; r.y += r.yv;
            if (r.x < 0 - r.r) r.x = canvas.width + r.r; else if (r.x > canvas.width + r.r) r.x = 0 - r.r;
            if (r.y < 0 - r.r) r.y = canvas.height + r.r; else if (r.y > canvas.height + r.r) r.y = 0 - r.r;
        }

        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 50;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
            p.x += p.xv; p.y += p.yv; p.life--;
            if(p.life <= 0) particles.splice(i, 1);
        }

        // --- COLISIONES ---
        if (!ship.dead) {
            for (let i = 0; i < roids.length; i++) {
                let rad = roids[i].r;
                if(roids[i].isSpiky) rad *= 0.8; 

                if (distBetweenPoints(ship.x, ship.y, roids[i].x, roids[i].y) < ship.r + rad) {
                    takeDamage(false); 
                    if(ship.hp <= 0 && lives > 0) destroyAsteroid(i);
                    break;
                }
            }
            for (let i = 0; i < mines.length; i++) {
                if (distBetweenPoints(ship.x, ship.y, mines[i].x, mines[i].y) < ship.r + mines[i].r + 5) {
                    takeDamage(true); 
                    destroyMine(i);
                    break;
                }
            }
        }
        
        for (let j = ship.lasers.length - 1; j >= 0; j--) {
            let hit = false;
            for (let i = roids.length - 1; i >= 0; i--) {
                if (distBetweenPoints(roids[i].x, roids[i].y, ship.lasers[j].x, ship.lasers[j].y) < roids[i].r) {
                    ship.lasers.splice(j, 1);
                    destroyAsteroid(i);
                    hit = true; break;
                }
            }
            if(hit) continue;
             for (let i = mines.length - 1; i >= 0; i--) {
                if(ship.lasers[j] && distBetweenPoints(mines[i].x, mines[i].y, ship.lasers[j].x, ship.lasers[j].y) < mines[i].r + 5) {
                    ship.lasers.splice(j, 1);
                    destroyMine(i);
                    break;
                }
            }
        }

        ship.a += ship.rot;
        ship.x += ship.thrust.x;
        ship.y += ship.thrust.y;
        if (ship.x < 0 - ship.r) ship.x = canvas.width + ship.r; else if (ship.x > canvas.width + ship.r) ship.x = 0 - ship.r;
        if (ship.y < 0 - ship.r) ship.y = canvas.height + ship.r; else if (ship.y > canvas.height + ship.r) ship.y = 0 - ship.r;

        requestAnimationFrame(loop);
    };

    newGame();

</script>
</body>
</html>